xc_diag_m=dependP_diags_gaus(T,m,x,gaus_mean_last,gaus_sd_last)
Forward_m=function(xc_diag_m,T,initP,transP){
alpha_m=t(initP)%*%diag(xc_diag_m[1,]) # T*m, row i for t=i
for (t in 2:T){
alpha_t=t(initP)%*%diag(xc_diag_m[1,]) # len m vec
for (tt in 2:t){
alpha_t=alpha_t%*%transP%*%diag(xc_diag_m[tt,],m,m)
}
alpha_m=rbind(alpha_m,alpha_t)
}
return(alpha_m)
}
alpha_m=Forward_m(xc_diag_m,T,initP,transP)
# backward prob
Backward_m=function(xc_diag_m,transP){
beta_m=matrix(NA,nrow=T,ncol=m) # T*m, row i for t=i
for (t in 1:T-1){
beta_t=diag(1,m)
for (tt in (t+1):T){
beta_t=beta_t%*%transP%*%diag(xc_diag_m[tt,],m)
}
beta_t=beta_t%*%(matrix(1,nrow=m,ncol=1))
beta_m[t,]=beta_t
}
#Tth beta
beta_m[T,]=rep(1,m)
return(beta_m)
}
beta_m=Backward_m(xc_diag_m,transP)
list_alpha_beta_m=list(alpha_m,beta_m)
names(list_alpha_beta_m)=c("alpha_m","beta_m")
return(list_alpha_beta_m)
}
#E step----------------------------------------------------
E_step=function(alpha_m,beta_m,T){
L_T=as.numeric(t(alpha_m[1,])%*%beta_m[1,])
u_jt_m=alpha_m*beta_m/L_T #T*m, row i for t=i
# v_jkt
v_jkt_m=c() #jkt:123 (alpha,beta,t), t:2:T
for (t in 2:T){
v_jk_t=alpha_m[t-1,]%*%t(beta_m[t,]) #ij:alpha_t-1(i)*beta_t+1(j)
v_jkt_m=abind(v_jkt_m,v_jk_t,along=3)
}
list_uv=list(u_jt_m,v_jkt_m)
names(list_uv)=c("u_jt_m","v_jkt_m")
return(list_uv)
}
#M step-----------------------------------------------------
M_step=function(u_jt_m,v_jkt_m,x,m,T,gaus_var_last){
# initial distribution
initP=u_jt_m[1,]/sum(u_jt_m[1,])
# transition prob
f_jk=apply(v_jkt_m,c(1,2),sum)
denominator_m=t(matrix(rep(rowSums(f_jk,dims = 1),m),m,m,byrow = TRUE))
transP=f_jk/denominator_m
# dependP
x_m=t(matrix(rep(x,m),m,T,byrow=TRUE))
#gaus_mean
gaus_var_m=matrix(rep(gaus_var_last,T),T,m,byrow = TRUE)
numerator_mu=colSums(x_m*u_jt_m/gaus_var_m)
denominator_mu=colSums(u_jt_m/gaus_var_m)
gaus_mean=numerator_mu/denominator_mu
#gaus_var (need gaus_mean)
gaus_mean_m=matrix(rep(gaus_mean,T),T,m,byrow = TRUE)
numerator_var=colSums((x_m-gaus_mean_m)^2*u_jt_m,dims=1)
denominator_var=colSums(u_jt_m,dims = 1)
gaus_var=numerator_var/denominator_var
list_mstep_para_gaus=list(initP,transP,gaus_mean,gaus_var)
names(list_mstep_para_gaus)=c("initP","transP","gaus_mean","gaus_var")
return(list_mstep_para_gaus)
}
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_var=last)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_var_last)
gaus_var_last=c(1,3)
gaus_sd_last=sqrt(c(1,3))
gaus_mean_last=c(0,0)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_var_last)
xc_diag_m
x
m=2
out=DGP(T,transP,initP,dependP)
x=out$X
initP=c(0.25,0.75)
transP=matrix(c(0.8,0.2,0.25,0.75),nrow=2,byrow=TRUE)
dependP=cbind(c(0,0),c(1,4))
colnames(dependP)=c("mean","var")
DGP=function(T,transP,initP,dependP){
C=X=numeric(T)
C[1]=sample(c(1,2),size=1,prob=initP)
X[1]=rnorm(n=1,mean=dependP[C[1],1],sd=sqrt(dependP[C[1],2]))
for(it in 2:T){
p=transP[C[it-1],]
C[it]=sample(c(1,2),size=1,prob=p)
X[it]=rnorm(n=1,mean=dependP[C[it],1],sd=sqrt(dependP[C[it],2]))
}
out=list(C,X)
names(out)=c("C","X")
return(out)
}
x=out$X
out
initP=c(0.25,0.75)
transP=matrix(c(0.8,0.2,0.25,0.75),nrow=2,byrow=TRUE)
dependP=cbind(c(0,0),c(1,4))
colnames(dependP)=c("mean","var")
DGP=function(T,transP,initP,dependP){
C=X=numeric(T)
C[1]=sample(c(1,2),size=1,prob=initP)
X[1]=rnorm(n=1,mean=dependP[C[1],1],sd=sqrt(dependP[C[1],2]))
for(it in 2:T){
p=transP[C[it-1],]
C[it]=sample(c(1,2),size=1,prob=p)
X[it]=rnorm(n=1,mean=dependP[C[it],1],sd=sqrt(dependP[C[it],2]))
}
out=list(C,X)
names(out)=c("C","X")
return(out)
}
m=2
out=DGP(T,transP,initP,dependP)
numeric(T)
help(numeric)
T
T=20
m=2
out=DGP(T,transP,initP,dependP)
x=out$X
x=out$X
x
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_var_last)
xc_diag_m
x
T
m
xc_diag_m
#Testing
T=225
initP=c(0.25,0.75)
transP=matrix(c(0.8,0.2,0.25,0.75),nrow=2,byrow=TRUE)
dependP=cbind(c(0,0),c(1,4))
colnames(dependP)=c("mean","var")
DGP=function(T,transP,initP,dependP){
C=X=numeric(T)
C[1]=sample(c(1,2),size=1,prob=initP)
X[1]=rnorm(n=1,mean=dependP[C[1],1],sd=sqrt(dependP[C[1],2]))
for(it in 2:T){
p=transP[C[it-1],]
C[it]=sample(c(1,2),size=1,prob=p)
X[it]=rnorm(n=1,mean=dependP[C[it],1],sd=sqrt(dependP[C[it],2]))
}
out=list(C,X)
names(out)=c("C","X")
return(out)
}
m=2
out=DGP(T,transP,initP,dependP)
x=out$X
initP=c(0.25,0.75)
transP=matrix(c(0.8,0.2,0.25,0.75),nrow=2,byrow=TRUE)
dependP=cbind(c(0,0),c(1,4))
gaus_var_last=c(1,3)
gaus_sd_last=sqrt(c(1,3))
gaus_mean_last=c(0,0)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean=c(-1,1),gaus_var=c(0.5,2))
xc_diag_m
#This script conduct E-M algorithm for Gaussian distribution
# generate diags of P(x_t) for all x_t---------------------
dependP_diags_gaus=function(T,m,x,gaus_mean_last,gaus_var_last){
gaus_sd=sqrt(gaus_var)
xc_diag_m=c() # combine of row of P(x_t), jth row for diags of P(x_j)
for (j in 1:T){
xc_diag_r=c() # diag entries for P(x_t), ith entry is P(x_t|c_i)
for (i in 1:m){
xc_diag_r=c(xc_diag_r,dnorm(x[j],gaus_mean_last[i],gaus_sd_last[i]))
}
xc_diag_m=rbind(xc_diag_m,xc_diag_r)
}
return(xc_diag_m)
}
# calculate forward-backward probability-----------------
Forward_Backward_gaus=function(T,transP,initP,xc_diag_m,x,
gaus_mean_last,gaus_sd_last){
# forward prob
xc_diag_m=dependP_diags_gaus(T,m,x,gaus_mean_last,gaus_sd_last)
Forward_m=function(xc_diag_m,T,initP,transP){
alpha_m=t(initP)%*%diag(xc_diag_m[1,]) # T*m, row i for t=i
for (t in 2:T){
alpha_t=t(initP)%*%diag(xc_diag_m[1,]) # len m vec
for (tt in 2:t){
alpha_t=alpha_t%*%transP%*%diag(xc_diag_m[tt,],m,m)
}
alpha_m=rbind(alpha_m,alpha_t)
}
return(alpha_m)
}
alpha_m=Forward_m(xc_diag_m,T,initP,transP)
# backward prob
Backward_m=function(xc_diag_m,transP){
beta_m=matrix(NA,nrow=T,ncol=m) # T*m, row i for t=i
for (t in 1:T-1){
beta_t=diag(1,m)
for (tt in (t+1):T){
beta_t=beta_t%*%transP%*%diag(xc_diag_m[tt,],m)
}
beta_t=beta_t%*%(matrix(1,nrow=m,ncol=1))
beta_m[t,]=beta_t
}
#Tth beta
beta_m[T,]=rep(1,m)
return(beta_m)
}
beta_m=Backward_m(xc_diag_m,transP)
list_alpha_beta_m=list(alpha_m,beta_m)
names(list_alpha_beta_m)=c("alpha_m","beta_m")
return(list_alpha_beta_m)
}
#E step----------------------------------------------------
E_step_gaus=function(alpha_m,beta_m,T){
L_T=as.numeric(t(alpha_m[1,])%*%beta_m[1,])
u_jt_m=alpha_m*beta_m/L_T #T*m, row i for t=i
# v_jkt
v_jkt_m=c() #jkt:123 (alpha,beta,t), t:2:T
for (t in 2:T){
v_jk_t=alpha_m[t-1,]%*%t(beta_m[t,]) #ij:alpha_t-1(i)*beta_t+1(j)
v_jkt_m=abind(v_jkt_m,v_jk_t,along=3)
}
list_uv=list(u_jt_m,v_jkt_m)
names(list_uv)=c("u_jt_m","v_jkt_m")
return(list_uv)
}
#M step-----------------------------------------------------
M_step_gaus=function(u_jt_m,v_jkt_m,x,m,T,gaus_var_last){
# initial distribution
initP=u_jt_m[1,]/sum(u_jt_m[1,])
# transition prob
f_jk=apply(v_jkt_m,c(1,2),sum)
denominator_m=t(matrix(rep(rowSums(f_jk,dims = 1),m),m,m,byrow = TRUE))
transP=f_jk/denominator_m
# dependP
x_m=t(matrix(rep(x,m),m,T,byrow=TRUE))
#gaus_mean
gaus_var_m=matrix(rep(gaus_var_last,T),T,m,byrow = TRUE)
numerator_mu=colSums(x_m*u_jt_m/gaus_var_m)
denominator_mu=colSums(u_jt_m/gaus_var_m)
gaus_mean=numerator_mu/denominator_mu
#gaus_var (need gaus_mean)
gaus_mean_m=matrix(rep(gaus_mean,T),T,m,byrow = TRUE)
numerator_var=colSums((x_m-gaus_mean_m)^2*u_jt_m,dims=1)
denominator_var=colSums(u_jt_m,dims = 1)
gaus_var=numerator_var/denominator_var
list_mstep_para_gaus=list(initP,transP,gaus_mean,gaus_var)
names(list_mstep_para_gaus)=c("initP","transP","gaus_mean","gaus_var")
return(list_mstep_para_gaus)
}
gaus_var_last=c(1,3)
gaus_sd_last=sqrt(c(1,3))
gaus_mean_last=c(0,0)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_var_last)
help(dnorm)
#This script conduct E-M algorithm for Gaussian distribution
# generate diags of P(x_t) for all x_t---------------------
dependP_diags_gaus=function(T,m,x,gaus_mean_last,gaus_sd_last){
gaus_sd=sqrt(gaus_var)
xc_diag_m=c() # combine of row of P(x_t), jth row for diags of P(x_j)
for (j in 1:T){
xc_diag_r=c() # diag entries for P(x_t), ith entry is P(x_t|c_i)
for (i in 1:m){
xc_diag_r=c(xc_diag_r,dnorm(x[j],gaus_mean_last[i],sd=gaus_sd_last[i]))
}
xc_diag_m=rbind(xc_diag_m,xc_diag_r)
}
return(xc_diag_m)
}
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_var_last)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_sd_last)
#This script conduct E-M algorithm for Gaussian distribution
# generate diags of P(x_t) for all x_t---------------------
dependP_diags_gaus=function(T,m,x,gaus_mean_last,gaus_sd_last){
xc_diag_m=c() # combine of row of P(x_t), jth row for diags of P(x_j)
for (j in 1:T){
xc_diag_r=c() # diag entries for P(x_t), ith entry is P(x_t|c_i)
for (i in 1:m){
xc_diag_r=c(xc_diag_r,dnorm(x[j],gaus_mean_last[i],sd=gaus_sd_last[i]))
}
xc_diag_m=rbind(xc_diag_m,xc_diag_r)
}
return(xc_diag_m)
}
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_sd_last)
xc_diag_m
list_alpha_beta_m=Forward_Backward(T,transP,initP,xc_diag_m,x,gaus_mean_last,
gaus_sd_last)
alpha_m=list_alpha_beta_m$alpha_m
beta_m=list_alpha_beta_m$beta_m
list_uv=E_step(alpha_m,beta_m,T)
u_jt_m=list_uv$u_jt_m
v_jktt_m=list_uv$v_jkt_m
dist_type='gaussian'
list_mstep_para_gaus=M_step(u_jt_m,v_jkt_m,x,m,T,gaus_var_last,
dist_type)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_sd_last)
list_alpha_beta_m=Forward_Backward(T,transP,initP,xc_diag_m,x,gaus_mean_last,
gaus_sd_last)
alpha_m=list_alpha_beta_m$alpha_m
beta_m=list_alpha_beta_m$beta_m
list_uv=E_step(alpha_m,beta_m,T)
u_jt_m=list_uv$u_jt_m
v_jktt_m=list_uv$v_jkt_m
list_mstep_para_gaus=M_step(u_jt_m,v_jkt_m,x,m,T,(gaus_sd_last)^2)
#Install packages--------------------------------------
PackageList =c('abind')
NewPackages=PackageList[!(PackageList %in%
installed.packages()[,"Package"])]
if(length(NewPackages)) install.packages(NewPackages)
lapply(PackageList,require,character.only=TRUE)
#Simulation----------------------------------------------
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_sd_last)
list_alpha_beta_m=Forward_Backward(T,transP,initP,xc_diag_m,x,gaus_mean_last,
gaus_sd_last)
alpha_m=list_alpha_beta_m$alpha_m
beta_m=list_alpha_beta_m$beta_m
list_uv=E_step(alpha_m,beta_m,T)
u_jt_m=list_uv$u_jt_m
v_jktt_m=list_uv$v_jkt_m
list_mstep_para_gaus=M_step(u_jt_m,v_jkt_m,x,m,T,(gaus_sd_last)^2)
xc_diag_m=
dependP_diags_gaus(T,m=2,x,gaus_mean_last,gaus_sd_last)
list_alpha_beta_m=Forward_Backward(T,transP,initP,xc_diag_m,x,gaus_mean_last,
gaus_sd_last)
alpha_m=list_alpha_beta_m$alpha_m
beta_m=list_alpha_beta_m$beta_m
list_uv=E_step(alpha_m,beta_m,T)
u_jt_m=list_uv$u_jt_m
v_jkt_m=list_uv$v_jkt_m
list_mstep_para_gaus=M_step(u_jt_m,v_jkt_m,x,m,T,(gaus_sd_last)^2)
rm(list=ls())
#Step 1: load packages and functions--------------------------------------------
setwd("C:/Users/Lenovo/Desktop/git/STAT4011-Project-2")
PackageList =c('abind')
NewPackages=PackageList[!(PackageList %in%
installed.packages()[,"Package"])]
if(length(NewPackages)) install.packages(NewPackages)
lapply(PackageList,require,character.only=TRUE)
source("code/DGP.r")
source('code/EM_gaus.r')
source('code/EM_pois.R')
source("code/viterbi_gaus.R")
source("code/viterbi_pois.R")
#Step 2: Explore the Energy consumption data------------------------------------
samplesize=60
data4=read.csv("data/energy_rawdata.csv")
data4=data4[1:samplesize,]
x4=data4[,2]
#Step 2.1 model selection
gaus_mean_x4=mean(x4)
gaus_sd_last_x4=sqrt(var(x4))
len_table=length(2:4)+1
aic_bic_x4=array(NA,dim = c(2,len_table),dimnames = list(c('aic','bic'),c(paste0('m=',2:4),"selected m")))
for (m in 2:4){
#m=3
initP_last=rep(1/m,m)
transP_last=matrix(0.3/m,m,m)+matrix(c(rep(0.7,m),rep(0,m*(m-1))),m,m)
gaus_mean_last=rep(gaus_mean_x4,m)
gaus_sd_last=rep(gaus_sd_last_x4,m)
list_mstep_para_gaus=EM_gaus(T=length(x4),m,x4,gaus_mean_last,gaus_sd_last,
transP_last,initP_last,
num_ite=10^4,tol=10^(-10))
aic_x4_m=list_mstep_para_gaus$aic
bic_x4_m=list_mstep_para_gaus$bic
aic_bic_x4[1,m-1]=aic_x4_m
aic_bic_x4[2,m-1]=bic_x4_m
}
aic_bic_x4[1,len_table]=as.numeric(which.min(aic_bic_x4[1,])+1)
aic_bic_x4[2,len_table]=as.numeric(which.min(aic_bic_x4[2,])+1)
print(aic_bic_x4)
#Step 2.2 parameter estimation and State Classification
m=as.numeric(aic_bic_x4[1,len_table])
initP_last=rep(1/m,m)
transP_last=matrix(0.3/m,m,m)+matrix(c(rep(0.7,m),rep(0,m*(m-1))),m,m)
gaus_mean_last=rep(gaus_mean_x4,m)
gaus_sd_last=rep(gaus_sd_last_x4,m)
list_mstep_para_gaus=EM_gaus(T=length(x4),m,x4,gaus_mean_last,gaus_sd_last,
transP_last,initP_last,
num_ite=10^4,tol=10^(-3))
list_mstep_para_gaus
initP_est_x4=list_mstep_para_gaus$initP
transP_est_x4=list_mstep_para_gaus$transP
gaus_mean_est_x4=list_mstep_para_gaus$gaus_mean
gaus_var_est_x4=list_mstep_para_gaus$gaus_var
path=viterbi_gaus(initP_est_x4,transP_est_x4,gaus_mean_est_x4,gaus_var_est_x4,m,T=length(x4),x4)
path
#gaus_mean=gaus_mean_est_x2[order(gaus_mean_est_x2)]
path[path==1]=gaus_mean_est_x4[1]
path[path==2]=gaus_mean_est_x4[2]
path[path==3]=gaus_mean_est_x4[3]
#path[path==4]=gaus_mean[4]
#Plot the path
png("output/viterbi_energy.png",width=800,height=400)
par(mar = c(3, 3, 3, 8), xpd = TRUE)
plot(x4,type = "l",xlab = "time",ylab = "")
par(new=TRUE)
plot(path,type = "l",col="red",ylab = "state/data",yaxt='n',xlab = "time",
main="estimated hidden state")
dev.off()
#Step 2.3 density compare-------------------------------------------------------
T=500
s=rep(NA,T)
xr=rep(NA,T)
p_t=initP_est_x4
s[1]=which.max(p_t)
xr[1]=rnorm(1,gaus_mean_est_x4[s[1]],sqrt(gaus_var_est_x4[s[1]]))
for (t in 2:T){
p_t=initP_est_x4%*%transP_est_x4
s[t]=which.max(p_t)
xr[t]=rnorm(1,gaus_mean_est_x4[s[t]],sqrt(gaus_var_est_x4[s[t]]))
}
png("output/energy_density.png",width=800,height=400)
par(mar = c(2, 2, 2, 7), xpd = TRUE)
plot(density(x4))
par(new=TRUE)
plot(density(xr),col="red",yaxt="n",xaxt="n",
main="comparison between simulation and real data")
legend("topright", inset=c(-0.25, 0),legend=c("real data","simulated data"),
col=c("black", "red"),lty=1:2,cex = 0.6)
dev.off()
#Step 3: Explore the accident data----------------------------------------------
#Step 3.1 model select
samplesize=60
data3<-read.csv("data/accident_rawdata.csv")
x3<-data3[1:samplesize,]
c1<-as.numeric(gsub(",", "", x3$Total_Accident))
data3<-matrix(c1,ncol=1)
colnames(data3)="x"
x3=as.numeric(data3)
mean_x3=mean(x3)
len_table=length(2:4)+1
aic_bic_x3=array(NA,dim = c(2,len_table),dimnames = list(c('aic','bic'),c(paste0('m=',2:4),"selected m")))
for (m in 2:4){
#m=2
initP_last=rep(1/m,m)
transP_last=matrix(0.3/m,m,m)+matrix(c(rep(0.7,m),rep(0,m*(m-1))),m,m)
lambda_last=rep(mean_x3,m)
list_mstep_para_pois=EM_pois(T=length(x3),m,x3,lambda_last,
transP_last,initP_last,
num_ite=10^4,tol=10^(-30))
aic_x3_m=list_mstep_para_pois$aic
bic_x3_m=list_mstep_para_pois$bic
aic_bic_x3[1,m-1]=aic_x3_m
aic_bic_x3[2,m-1]=bic_x3_m
}
aic_bic_x3[1,len_table]=as.numeric(which.min(aic_bic_x3[1,])+1)
aic_bic_x3[2,len_table]=as.numeric(which.min(aic_bic_x3[2,])+1)
print(aic_bic_x3)
#Step 3.2 parameter estimation and viterbi algorithm
m=4
initP_last=rep(1/m,m)
#transP_last=matrix(c(0.1,0.9,0.8,0.2),2,2,byrow = TRUE)
transP_last=matrix(0.3/m,m,m)+matrix(c(rep(0.7,m),rep(0,m*(m-1))),m,m)
lambda_last=rep(300,m)
list_mstep_para_pois=EM_pois(T=length(x3),m,x3,lambda_last,
transP_last,initP_last,
num_ite=10^4,tol=10^(-30))
lambda_est_x3=list_mstep_para_pois$lambda
transP_est_x3=list_mstep_para_pois$transP
initP_est_x3=list_mstep_para_pois$initP
path=viterbi_pois(initP_est_x3,transP_est_x3,lambda_est_x3,m,T=length(x3),x3)
path
#lambda_x1=lambda_est_x1[order(gaus_mean_est_x2)]
path[path==1]=lambda_est_x3[1]
path[path==2]=lambda_est_x3[2]
path[path==3]=lambda_est_x3[3]
#path[path==4]=gaus_mean[4]
path
png("output/viterbi_accident.png",width=800,height=400)
par(mar = c(3, 3, 3, 8), xpd = TRUE)
plot(x3,type = "l",xlab = "time",ylab = "")
par(new=TRUE)
plot(path,type = "l",col="red",ylab = "",yaxt='n',xlab = "")
legend("topright", inset=c(-0.4, 0),legend=c("data", "viterbi result"),
col=c("black", "red"),lty=1:2,cex = 0.6)
dev.off()
#Step 3.3 density compare
T=500
s=rep(NA,T)
xr=rep(NA,T)
p_t=initP_est_x3
s[1]=which.max(p_t)
xr[1]=rpois(1,lambda_est_x3[s[1]])
for (t in 2:T){
p_t=initP_est_x3%*%transP_est_x3
s[t]=which.max(p_t)
xr[t]=rpois(1,lambda_est_x3[s[t]])
}
png("output/accident_density.png",width=800,height=400)
par(mar = c(2, 2, 2, 7), xpd = TRUE)
plot(density(x3))
par(new=TRUE)
plot(density(xr),col="red",yaxt="n",xaxt="n")
legend("topright", inset=c(-0.25, 0),legend=c("original data", "estimated"),
col=c("black", "red"),lty=1:2,cex = 0.6)
dev.off()
